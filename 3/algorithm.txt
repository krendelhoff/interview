Описываю алгоритм Бойера-Мура-Хорспула.

У нас есть строка haystack, в которой мы ищем подстроку, и искомая подстрока needle.
Для каждого символа алфавита мы заводим таблицу сдвигов. Алгоритм идейно такой же, как наивный, но сдвиги будут производиться не на один символ строки haystack, а на вычисленный нами сдвиг.

Для символа c, shift c = length needle - lastpos c (init needle)
где lastpos = 0, если c не содержится в (init needle), и равно позиции последнего вхождения в needle. Последний элемент не рассматриваем, т.к. shift = 0 приведет к расходимости. 

Асимптотическая и фактическая сложности в лучшем и худшем случае совпадают с наивным алгоритмом.
В лучшем случае - O(|needle|), фактическая - |needle| операций сравнения (needle `isPrefixOf` haystack == True)
В худшем случае такая же, как у наивной реализации - O(|needle| * |haystack|), фактическая так же буквально |needle| * |haystack| операций сравнения.
